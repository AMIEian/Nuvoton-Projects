; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xAN\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=535 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GetBoardID||, CODE, READONLY, ALIGN=2

                  GetBoardID PROC
;;;224    	
;;;225    void GetBoardID()
000000  b510              PUSH     {r4,lr}
;;;226    {
;;;227    	if(P00 == 0)
000002  4913              LDR      r1,|L1.80|
000004  680a              LDR      r2,[r1,#0]
;;;228    		boardID = boardID | 0x01;
000006  2301              MOVS     r3,#1
000008  4812              LDR      r0,|L1.84|
00000a  2a00              CMP      r2,#0                 ;227
00000c  d102              BNE      |L1.20|
00000e  7802              LDRB     r2,[r0,#0]  ; boardID
000010  431a              ORRS     r2,r2,r3
000012  7002              STRB     r2,[r0,#0]
                  |L1.20|
;;;229    	if(P01 == 0)
000014  684a              LDR      r2,[r1,#4]
000016  2a00              CMP      r2,#0
000018  d103              BNE      |L1.34|
;;;230    		boardID = boardID | 0x02;
00001a  7802              LDRB     r2,[r0,#0]  ; boardID
00001c  2402              MOVS     r4,#2
00001e  4322              ORRS     r2,r2,r4
000020  7002              STRB     r2,[r0,#0]
                  |L1.34|
;;;231    	if(P04 == 0)
000022  690a              LDR      r2,[r1,#0x10]
000024  2a00              CMP      r2,#0
000026  d103              BNE      |L1.48|
;;;232    		boardID = boardID | 0x04;
000028  7802              LDRB     r2,[r0,#0]  ; boardID
00002a  2404              MOVS     r4,#4
00002c  4322              ORRS     r2,r2,r4
00002e  7002              STRB     r2,[r0,#0]
                  |L1.48|
;;;233    	if(P05 == 0)
000030  694a              LDR      r2,[r1,#0x14]
000032  2a00              CMP      r2,#0
000034  d103              BNE      |L1.62|
;;;234    		boardID = boardID | 0x08;
000036  7802              LDRB     r2,[r0,#0]  ; boardID
000038  2408              MOVS     r4,#8
00003a  4322              ORRS     r2,r2,r4
00003c  7002              STRB     r2,[r0,#0]
                  |L1.62|
;;;235    	if(P06 == 0)
00003e  6989              LDR      r1,[r1,#0x18]
000040  2900              CMP      r1,#0
000042  d103              BNE      |L1.76|
;;;236    		boardID = boardID | 0x10;
000044  7801              LDRB     r1,[r0,#0]  ; boardID
000046  2210              MOVS     r2,#0x10
000048  4311              ORRS     r1,r1,r2
00004a  7001              STRB     r1,[r0,#0]
                  |L1.76|
;;;237    	boardID = 1;
00004c  7003              STRB     r3,[r0,#0]
;;;238    }
00004e  bd10              POP      {r4,pc}
;;;239    
                          ENDP

                  |L1.80|
                          DCD      0x50004200
                  |L1.84|
                          DCD      ||.data||

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;89     	
;;;90     void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92         /*---------------------------------------------------------------------------------------------------------*/
;;;93         /* Init System Clock                                                                                       */
;;;94         /*---------------------------------------------------------------------------------------------------------*/
;;;95         /* Enable IRC22M clock */
;;;96         CLK->PWRCON |= CLK_PWRCON_IRC22M_EN_Msk;
000002  4c13              LDR      r4,|L2.80|
000004  6820              LDR      r0,[r4,#0]
000006  2104              MOVS     r1,#4
000008  4308              ORRS     r0,r0,r1
00000a  6020              STR      r0,[r4,#0]
;;;97     
;;;98         /* Waiting for IRC22M clock ready */
;;;99         CLK_WaitClockReady(CLK_CLKSTATUS_IRC22M_STB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;100    
;;;101        /* Switch HCLK clock source to HIRC */
;;;102        CLK->CLKSEL0 = CLK_CLKSEL0_HCLK_S_HIRC;
000012  2007              MOVS     r0,#7
000014  6120              STR      r0,[r4,#0x10]
;;;103    
;;;104        /* Set PLL to Power-down mode and PLL_STB bit in CLKSTATUS register will be cleared by hardware.*/
;;;105        CLK->PLLCON |= CLK_PLLCON_PD_Msk;
000016  6a20              LDR      r0,[r4,#0x20]
000018  01e1              LSLS     r1,r4,#7
00001a  4308              ORRS     r0,r0,r1
00001c  6220              STR      r0,[r4,#0x20]
;;;106    
;;;107        /* Enable PLL and Set PLL frequency */
;;;108        CLK->PLLCON = PLLCON_SETTING;
00001e  480d              LDR      r0,|L2.84|
000020  6220              STR      r0,[r4,#0x20]
;;;109    
;;;110        /* Waiting for clock ready */
;;;111        CLK_WaitClockReady(CLK_CLKSTATUS_PLL_STB_Msk | CLK_CLKSTATUS_XTL12M_STB_Msk | CLK_CLKSTATUS_IRC10K_STB_Msk);
000022  200d              MOVS     r0,#0xd
000024  f7fffffe          BL       CLK_WaitClockReady
;;;112    
;;;113        /* Switch HCLK clock source to PLL, STCLK to HCLK/2 */
;;;114        CLK->CLKSEL0 = CLK_CLKSEL0_STCLK_S_HCLK_DIV2 | CLK_CLKSEL0_HCLK_S_PLL;
000028  201a              MOVS     r0,#0x1a
00002a  6120              STR      r0,[r4,#0x10]
;;;115    
;;;116        /* Enable peripheral clock */
;;;117        CLK->APBCLK = CLK_APBCLK_UART0_EN_Msk | CLK_APBCLK_TMR0_EN_Msk;
00002c  480a              LDR      r0,|L2.88|
00002e  60a0              STR      r0,[r4,#8]
;;;118    
;;;119        /* Peripheral clock source */
;;;120        CLK->CLKSEL1 = CLK_CLKSEL1_UART_S_PLL | CLK_CLKSEL1_TMR0_S_HIRC;
000030  480a              LDR      r0,|L2.92|
000032  6160              STR      r0,[r4,#0x14]
;;;121    
;;;122        /* Update System Core Clock */
;;;123        /* User can use SystemCoreClockUpdate() to calculate PllClock, SystemCoreClock and CycylesPerUs automatically. */
;;;124        SystemCoreClockUpdate();
000034  f7fffffe          BL       SystemCoreClockUpdate
;;;125    
;;;126        /*---------------------------------------------------------------------------------------------------------*/
;;;127        /* Init I/O Multi-function                                                                                 */
;;;128        /*---------------------------------------------------------------------------------------------------------*/
;;;129        /* Set P3 multi-function pins for UART0 RXD, TXD */
;;;130        SYS->P0_MFP &= ~(SYS_MFP_P03_Msk | SYS_MFP_P02_Msk);
000038  2005              MOVS     r0,#5
00003a  0700              LSLS     r0,r0,#28
00003c  6b01              LDR      r1,[r0,#0x30]
00003e  4a08              LDR      r2,|L2.96|
000040  4011              ANDS     r1,r1,r2
000042  6301              STR      r1,[r0,#0x30]
;;;131        SYS->P0_MFP |= (SYS_MFP_P03_RXD0 | SYS_MFP_P02_TXD0);
000044  6b01              LDR      r1,[r0,#0x30]
000046  43d2              MVNS     r2,r2
000048  4311              ORRS     r1,r1,r2
00004a  6301              STR      r1,[r0,#0x30]
;;;132    }
00004c  bd10              POP      {r4,pc}
;;;133    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      0x50000200
                  |L2.84|
                          DCD      0x00085639
                  |L2.88|
                          DCD      0x00010004
                  |L2.92|
                          DCD      0x01000700
                  |L2.96|
                          DCD      0xfffff3f3

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  TMR0_IRQHandler PROC
;;;63      */
;;;64     void TMR0_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
000002  4914              LDR      r1,|L3.84|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;65     	{
00000a  d00e              BEQ      |L3.42|
00000c  2501              MOVS     r5,#1
00000e  608d              STR      r5,[r1,#8]
;;;66     			if(TIMER_GetIntFlag(TIMER0) == 1)
;;;67     				{
;;;68     						/* Clear Timer0 time-out interrupt flag */
;;;69     						TIMER_ClearIntFlag(TIMER0);			
;;;70     						//GPIO_TOGGLE(P07);
;;;71     						if(dataReceiving == 0)
000010  4c11              LDR      r4,|L3.88|
000012  6961              LDR      r1,[r4,#0x14]  ; dataReceiving
000014  2000              MOVS     r0,#0
000016  2900              CMP      r1,#0
000018  d008              BEQ      |L3.44|
;;;72     							{
;;;73     								P07 = 0;
;;;74     								for(i = 0; i < 8; i++)
;;;75     									printf("%c", masterCommand[i]);
;;;76     								P07 = 1;
;;;77     							}	
;;;78     						else
;;;79     							{
;;;80     								seconds = seconds + 1;
00001a  69e1              LDR      r1,[r4,#0x1c]  ; seconds
00001c  1c49              ADDS     r1,r1,#1
00001e  61e1              STR      r1,[r4,#0x1c]  ; seconds
;;;81     								if(seconds >= 5)
000020  69e1              LDR      r1,[r4,#0x1c]  ; seconds
000022  2905              CMP      r1,#5
000024  d301              BCC      |L3.42|
;;;82     									{
;;;83     										seconds = 0;
000026  61e0              STR      r0,[r4,#0x1c]  ; seconds
;;;84     										dataReceiving = 0;
000028  6160              STR      r0,[r4,#0x14]  ; dataReceiving
                  |L3.42|
;;;85     									}
;;;86     							}					
;;;87     				}
;;;88     	}
00002a  bdf8              POP      {r3-r7,pc}
                  |L3.44|
00002c  4e0b              LDR      r6,|L3.92|
00002e  61f0              STR      r0,[r6,#0x1c]         ;73
000030  6220              STR      r0,[r4,#0x20]         ;74  ; i
000032  4f09              LDR      r7,|L3.88|
000034  3724              ADDS     r7,r7,#0x24           ;75
000036  e007              B        |L3.72|
                  |L3.56|
000038  6a20              LDR      r0,[r4,#0x20]         ;75  ; i
00003a  5c39              LDRB     r1,[r7,r0]            ;75
00003c  a008              ADR      r0,|L3.96|
00003e  f7fffffe          BL       __2printf
000042  6a20              LDR      r0,[r4,#0x20]         ;74  ; i
000044  1c40              ADDS     r0,r0,#1              ;74
000046  6220              STR      r0,[r4,#0x20]         ;74  ; i
                  |L3.72|
000048  6a20              LDR      r0,[r4,#0x20]         ;74  ; i
00004a  2808              CMP      r0,#8                 ;74
00004c  d3f4              BCC      |L3.56|
00004e  61f5              STR      r5,[r6,#0x1c]         ;76
000050  bdf8              POP      {r3-r7,pc}
;;;89     	
                          ENDP

000052  0000              DCW      0x0000
                  |L3.84|
                          DCD      0x40010000
                  |L3.88|
                          DCD      ||.data||
                  |L3.92|
                          DCD      0x50004200
                  |L3.96|
000060  256300            DCB      "%c",0
000063  00                DCB      0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=1

                  UART0_IRQHandler PROC
;;;219    
;;;220    void UART0_IRQHandler(void)
000000  b500              PUSH     {lr}
;;;221    {
;;;222    		UART_TEST_HANDLE();
000002  f7fffffe          BL       UART_TEST_HANDLE
;;;223    }
000006  bd00              POP      {pc}
;;;224    	
                          ENDP


                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;133    
;;;134    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136        /*---------------------------------------------------------------------------------------------------------*/
;;;137        /* Init UART                                                                                               */
;;;138        /*---------------------------------------------------------------------------------------------------------*/
;;;139        /* Reset IP */
;;;140        SYS_ResetModule(UART0_RST);
000002  4804              LDR      r0,|L5.20|
000004  f7fffffe          BL       SYS_ResetModule
;;;141    
;;;142        /* Configure UART0 and set UART0 Baudrate */
;;;143        UART_Open(UART0, 9600);
000008  214b              MOVS     r1,#0x4b
00000a  01c9              LSLS     r1,r1,#7
00000c  4802              LDR      r0,|L5.24|
00000e  f7fffffe          BL       UART_Open
;;;144    }
000012  bd10              POP      {r4,pc}
;;;145    
                          ENDP

                  |L5.20|
                          DCD      0x04000010
                  |L5.24|
                          DCD      0x40050000

                          AREA ||i.UART_TEST_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_TEST_HANDLE PROC
;;;148    /*---------------------------------------------------------------------------------------------------------*/
;;;149    void UART_TEST_HANDLE()
000000  b5f0              PUSH     {r4-r7,lr}
;;;150    {
;;;151    	uint8_t u8InChar = 0xFF;
;;;152    	uint32_t u32IntSts = UART0->ISR;
000002  4834              LDR      r0,|L6.212|
000004  69c5              LDR      r5,[r0,#0x1c]
;;;153    
;;;154    	if(u32IntSts & UART_ISR_RDA_INT_Msk)
000006  2400              MOVS     r4,#0
000008  05e8              LSLS     r0,r5,#23
;;;155    		{
;;;156    			/* Get all the input characters */
;;;157    			while(UART_IS_RX_READY(UART0))
;;;158    				{
;;;159    					/* Get the character from UART Buffer */
;;;160    					u8InChar = UART_READ(UART0);
;;;161    					if(dataReceiving == 1)
;;;162    						{
;;;163    							responce[arrayIndex] = u8InChar;					
00000a  4a33              LDR      r2,|L6.216|
;;;164    							if(arrayIndex == 1)
;;;165    								{
;;;166    									if(responce[arrayIndex] != 0x03)
;;;167    										{
;;;168    											dataReceiving = 0;
;;;169    											arrayIndex = 0;
;;;170    										}
;;;171    								}
;;;172    							if(arrayIndex == 2)
;;;173    								{
;;;174    									if(responce[arrayIndex] != 0x0C)
;;;175    										{
;;;176    											dataReceiving = 0;
;;;177    											arrayIndex = 0;
;;;178    										}
;;;179    								}
;;;180    							arrayIndex = arrayIndex + 1;
;;;181    							if(arrayIndex == 15)
;;;182    								{
;;;183    									dataReceiving = 0;
;;;184    									arrayIndex = 0;
;;;185    									dataReceived = 1;
00000c  2601              MOVS     r6,#1
00000e  4933              LDR      r1,|L6.220|
000010  2800              CMP      r0,#0                 ;154
000012  db41              BLT      |L6.152|
000014  e044              B        |L6.160|
                  |L6.22|
000016  6800              LDR      r0,[r0,#0]            ;160
000018  694b              LDR      r3,[r1,#0x14]         ;161  ; dataReceiving
00001a  b2c0              UXTB     r0,r0                 ;160
00001c  2b01              CMP      r3,#1                 ;161
00001e  d11c              BNE      |L6.90|
000020  690b              LDR      r3,[r1,#0x10]         ;163  ; arrayIndex
000022  54d0              STRB     r0,[r2,r3]            ;163
000024  690b              LDR      r3,[r1,#0x10]         ;164  ; arrayIndex
000026  2b01              CMP      r3,#1                 ;164
000028  d105              BNE      |L6.54|
00002a  690b              LDR      r3,[r1,#0x10]         ;166  ; arrayIndex
00002c  5cd3              LDRB     r3,[r2,r3]            ;166
00002e  2b03              CMP      r3,#3                 ;166
000030  d001              BEQ      |L6.54|
000032  614c              STR      r4,[r1,#0x14]         ;168  ; dataReceiving
000034  610c              STR      r4,[r1,#0x10]         ;169  ; arrayIndex
                  |L6.54|
000036  690b              LDR      r3,[r1,#0x10]         ;172  ; arrayIndex
000038  2b02              CMP      r3,#2                 ;172
00003a  d105              BNE      |L6.72|
00003c  690b              LDR      r3,[r1,#0x10]         ;174  ; arrayIndex
00003e  5cd3              LDRB     r3,[r2,r3]            ;174
000040  2b0c              CMP      r3,#0xc               ;174
000042  d001              BEQ      |L6.72|
000044  614c              STR      r4,[r1,#0x14]         ;176  ; dataReceiving
000046  610c              STR      r4,[r1,#0x10]         ;177  ; arrayIndex
                  |L6.72|
000048  690b              LDR      r3,[r1,#0x10]         ;180  ; arrayIndex
00004a  1c5b              ADDS     r3,r3,#1              ;180
00004c  610b              STR      r3,[r1,#0x10]         ;180  ; arrayIndex
00004e  690b              LDR      r3,[r1,#0x10]         ;181  ; arrayIndex
000050  2b0f              CMP      r3,#0xf               ;181
000052  d102              BNE      |L6.90|
000054  614c              STR      r4,[r1,#0x14]         ;183  ; dataReceiving
000056  610c              STR      r4,[r1,#0x10]         ;184  ; arrayIndex
000058  618e              STR      r6,[r1,#0x18]  ; dataReceived
                  |L6.90|
;;;186    								}
;;;187    						}
;;;188    					if(u8InChar == 0x01 && dataReceiving == 0)
00005a  2801              CMP      r0,#1
00005c  d108              BNE      |L6.112|
00005e  694b              LDR      r3,[r1,#0x14]  ; dataReceiving
000060  2b00              CMP      r3,#0
000062  d105              BNE      |L6.112|
;;;189    						{
;;;190    							responce[arrayIndex] = u8InChar;
000064  690b              LDR      r3,[r1,#0x10]  ; arrayIndex
000066  54d0              STRB     r0,[r2,r3]
;;;191    							dataReceiving = 1;
000068  614e              STR      r6,[r1,#0x14]  ; dataReceiving
;;;192    							arrayIndex = arrayIndex + 1;
00006a  690b              LDR      r3,[r1,#0x10]  ; arrayIndex
00006c  1c5b              ADDS     r3,r3,#1
00006e  610b              STR      r3,[r1,#0x10]  ; arrayIndex
                  |L6.112|
;;;193    						}
;;;194    
;;;195    					/* Check if buffer full */
;;;196    					if(g_u32comRbytes < RXBUFSIZE)
000070  684b              LDR      r3,[r1,#4]  ; g_u32comRbytes
000072  2701              MOVS     r7,#1
000074  02bf              LSLS     r7,r7,#10
000076  42bb              CMP      r3,r7
000078  d20e              BCS      |L6.152|
;;;197    						{
;;;198    								/* Enqueue the character */
;;;199    								g_u8RecData[g_u32comRtail] = u8InChar;
00007a  4b19              LDR      r3,|L6.224|
00007c  68cf              LDR      r7,[r1,#0xc]  ; g_u32comRtail
00007e  55d8              STRB     r0,[r3,r7]
;;;200    								g_u32comRtail = (g_u32comRtail == (RXBUFSIZE - 1)) ? 0 : (g_u32comRtail + 1);
000080  68cb              LDR      r3,[r1,#0xc]  ; g_u32comRtail
000082  4818              LDR      r0,|L6.228|
000084  4283              CMP      r3,r0
000086  d101              BNE      |L6.140|
000088  2000              MOVS     r0,#0
00008a  e001              B        |L6.144|
                  |L6.140|
00008c  68c8              LDR      r0,[r1,#0xc]  ; g_u32comRtail
00008e  1c40              ADDS     r0,r0,#1
                  |L6.144|
000090  60c8              STR      r0,[r1,#0xc]  ; g_u32comRtail
;;;201    								g_u32comRbytes++;
000092  6848              LDR      r0,[r1,#4]  ; g_u32comRbytes
000094  1c40              ADDS     r0,r0,#1
000096  6048              STR      r0,[r1,#4]  ; g_u32comRbytes
                  |L6.152|
000098  480e              LDR      r0,|L6.212|
00009a  69c3              LDR      r3,[r0,#0x1c]         ;157
00009c  07db              LSLS     r3,r3,#31             ;157
00009e  d1ba              BNE      |L6.22|
                  |L6.160|
;;;202    						}
;;;203    				}
;;;204    		}
;;;205    
;;;206    	if(u32IntSts & UART_ISR_THRE_INT_Msk)
0000a0  05a8              LSLS     r0,r5,#22
0000a2  d515              BPL      |L6.208|
;;;207    		{
;;;208    			uint16_t tmp;
;;;209    			tmp = g_u32comRtail;
0000a4  68c8              LDR      r0,[r1,#0xc]  ; g_u32comRtail
;;;210    			if(g_u32comRhead != tmp)
0000a6  688a              LDR      r2,[r1,#8]  ; g_u32comRhead
0000a8  b280              UXTH     r0,r0                 ;209
0000aa  4282              CMP      r2,r0
0000ac  d010              BEQ      |L6.208|
;;;211    				{
;;;212    						u8InChar = g_u8RecData[g_u32comRhead];
0000ae  6888              LDR      r0,[r1,#8]  ; g_u32comRhead
0000b0  4808              LDR      r0,|L6.212|
                  |L6.178|
;;;213    						while(UART_IS_TX_FULL(UART0));  /* Wait Tx is not full to transmit data */
0000b2  6982              LDR      r2,[r0,#0x18]
0000b4  0212              LSLS     r2,r2,#8
0000b6  d4fc              BMI      |L6.178|
;;;214    						g_u32comRhead = (g_u32comRhead == (RXBUFSIZE - 1)) ? 0 : (g_u32comRhead + 1);
0000b8  688a              LDR      r2,[r1,#8]  ; g_u32comRhead
0000ba  480a              LDR      r0,|L6.228|
0000bc  4282              CMP      r2,r0
0000be  d101              BNE      |L6.196|
0000c0  2000              MOVS     r0,#0
0000c2  e001              B        |L6.200|
                  |L6.196|
0000c4  6888              LDR      r0,[r1,#8]  ; g_u32comRhead
0000c6  1c40              ADDS     r0,r0,#1
                  |L6.200|
0000c8  6088              STR      r0,[r1,#8]  ; g_u32comRhead
;;;215    						g_u32comRbytes--;
0000ca  6848              LDR      r0,[r1,#4]  ; g_u32comRbytes
0000cc  1e40              SUBS     r0,r0,#1
0000ce  6048              STR      r0,[r1,#4]  ; g_u32comRbytes
                  |L6.208|
;;;216    				}
;;;217    		}
;;;218    }
0000d0  bdf0              POP      {r4-r7,pc}
;;;219    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L6.212|
                          DCD      0x40050000
                  |L6.216|
                          DCD      ||.bss||+0x400
                  |L6.220|
                          DCD      ||.data||
                  |L6.224|
                          DCD      ||.bss||
                  |L6.228|
                          DCD      0x000003ff

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;242    /*---------------------------------------------------------------------------------------------------------*/
;;;243    int main(void)
000000  2159              MOVS     r1,#0x59
000002  2016              MOVS     r0,#0x16
000004  4c3d              LDR      r4,|L7.252|
000006  2288              MOVS     r2,#0x88
000008  e002              B        |L7.16|
                  |L7.10|
00000a  6021              STR      r1,[r4,#0]
00000c  6020              STR      r0,[r4,#0]
00000e  6022              STR      r2,[r4,#0]
                  |L7.16|
000010  6823              LDR      r3,[r4,#0]
000012  2b01              CMP      r3,#1
000014  d1f9              BNE      |L7.10|
;;;244    	{
;;;245    			/* Unlock protected registers */
;;;246    			SYS_UnlockReg();
;;;247    
;;;248    			/* Init System, peripheral clock and multi-function I/O */
;;;249    			SYS_Init();
000016  f7fffffe          BL       SYS_Init
00001a  2000              MOVS     r0,#0
00001c  6020              STR      r0,[r4,#0]
;;;250    
;;;251    			/* Lock protected registers */
;;;252    			SYS_LockReg();
;;;253    		
;;;254    			/* Init UART0 for printf */
;;;255    			UART0_Init();	
00001e  f7fffffe          BL       UART0_Init
;;;256    			
;;;257    			/* Open Timer0 frequency to 0.5 Hz in periodic mode, and enable interrupt */
;;;258    			TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1);
000022  4c37              LDR      r4,|L7.256|
000024  2201              MOVS     r2,#1
000026  06d1              LSLS     r1,r2,#27
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       TIMER_Open
00002e  6820              LDR      r0,[r4,#0]
000030  0361              LSLS     r1,r4,#13
000032  4308              ORRS     r0,r0,r1
000034  6020              STR      r0,[r4,#0]
000036  4833              LDR      r0,|L7.260|
000038  1549              ASRS     r1,r1,#21
00003a  6001              STR      r1,[r0,#0]
00003c  6820              LDR      r0,[r4,#0]
00003e  0589              LSLS     r1,r1,#22
000040  4308              ORRS     r0,r0,r1
000042  6020              STR      r0,[r4,#0]
;;;259    			TIMER_EnableInt(TIMER0);
;;;260    
;;;261    			/* Enable Timer0 ~ Timer3 NVIC */
;;;262    			NVIC_EnableIRQ(TMR0_IRQn);
;;;263    
;;;264    			/* Start Timer0 ~ Timer3 counting */
;;;265    			TIMER_Start(TIMER0);
;;;266    
;;;267    			GPIO_SetMode(P0, BIT0 | BIT1 | BIT4 | BIT5 | BIT6, GPIO_PMD_INPUT);
000044  4c30              LDR      r4,|L7.264|
000046  2200              MOVS     r2,#0
000048  2173              MOVS     r1,#0x73
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       GPIO_SetMode
;;;268    			GPIO_SetMode(P0, BIT7, GPIO_PMD_OUTPUT);
000050  2201              MOVS     r2,#1
000052  2180              MOVS     r1,#0x80
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       GPIO_SetMode
;;;269    			GPIO_SetMode(P1, BIT0 | BIT1 | BIT2 | BIT3 | BIT4 | BIT5 | BIT6 | BIT7, GPIO_PMD_OUTPUT);
00005a  4c2b              LDR      r4,|L7.264|
00005c  2201              MOVS     r2,#1
00005e  3440              ADDS     r4,r4,#0x40
000060  21ff              MOVS     r1,#0xff
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       GPIO_SetMode
;;;270    			GPIO_SetMode(P2, BIT0 | BIT1 | BIT2 | BIT3 | BIT4 | BIT5 | BIT6 | BIT7, GPIO_PMD_OUTPUT);
000068  4d27              LDR      r5,|L7.264|
00006a  2201              MOVS     r2,#1
00006c  3580              ADDS     r5,r5,#0x80
00006e  21ff              MOVS     r1,#0xff
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       GPIO_SetMode
;;;271    			GPIO_SetMode(P3, BIT0 | BIT1 | BIT2 | BIT3 | BIT4 | BIT5 | BIT6 | BIT7, GPIO_PMD_OUTPUT);
000076  4e24              LDR      r6,|L7.264|
000078  2201              MOVS     r2,#1
00007a  36c0              ADDS     r6,r6,#0xc0
00007c  21ff              MOVS     r1,#0xff
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       GPIO_SetMode
;;;272    			GPIO_SetMode(P4, BIT0 | BIT1 | BIT2 | BIT3 | BIT4 | BIT5 | BIT6 | BIT7, GPIO_PMD_OUTPUT);
000084  4f21              LDR      r7,|L7.268|
000086  2201              MOVS     r2,#1
000088  21ff              MOVS     r1,#0xff
00008a  4638              MOV      r0,r7
00008c  f7fffffe          BL       GPIO_SetMode
;;;273    		
;;;274    			GetBoardID();	
000090  f7fffffe          BL       GetBoardID
;;;275    			
;;;276    			/* Enable Interrupt and install the call back function */
;;;277    			UART_ENABLE_INT(UART0, (UART_IER_RDA_IEN_Msk | UART_IER_THRE_IEN_Msk | UART_IER_RTO_IEN_Msk));
000094  481e              LDR      r0,|L7.272|
000096  6841              LDR      r1,[r0,#4]
000098  2213              MOVS     r2,#0x13
00009a  4311              ORRS     r1,r1,r2
00009c  6041              STR      r1,[r0,#4]
00009e  2101              MOVS     r1,#1
0000a0  4818              LDR      r0,|L7.260|
0000a2  0309              LSLS     r1,r1,#12
0000a4  6001              STR      r1,[r0,#0]
;;;278    			NVIC_EnableIRQ(UART0_IRQn);
;;;279    
;;;280    			while(1)
;;;281    				{
;;;282    					if(dataReceived == 1)
;;;283    						{
;;;284    							if(boardID == 1)
;;;285    								{
;;;286    									outp8(P1,responce[FIRST_REG_L]);
0000a6  481b              LDR      r0,|L7.276|
0000a8  491b              LDR      r1,|L7.280|
                  |L7.170|
0000aa  698a              LDR      r2,[r1,#0x18]         ;282  ; dataReceived
0000ac  2a01              CMP      r2,#1                 ;282
0000ae  d1fc              BNE      |L7.170|
0000b0  780a              LDRB     r2,[r1,#0]            ;284  ; boardID
0000b2  2a01              CMP      r2,#1                 ;284
0000b4  d006              BEQ      |L7.196|
;;;287    									outp8(P2,responce[FIRST_REG_H]);
;;;288    									outp8(P3,responce[SECOND_REG_L]);
;;;289    									outp8(P4,responce[SECOND_REG_H]);
;;;290    								}
;;;291    							else if(boardID == 2)
0000b6  780a              LDRB     r2,[r1,#0]  ; boardID
0000b8  2a02              CMP      r2,#2
0000ba  d00b              BEQ      |L7.212|
;;;292    								{
;;;293    									outp8(P1,responce[THIRD_REG_L]);
;;;294    									outp8(P2,responce[THIRD_REG_H]);
;;;295    									outp8(P3,responce[FOURTH_REG_L]);
;;;296    									outp8(P4,responce[FOURTH_REG_H]);
;;;297    								}
;;;298    							else if(boardID == 3)
0000bc  780a              LDRB     r2,[r1,#0]  ; boardID
0000be  2a03              CMP      r2,#3
0000c0  d010              BEQ      |L7.228|
0000c2  e017              B        |L7.244|
                  |L7.196|
0000c4  7902              LDRB     r2,[r0,#4]            ;286  ; responce
0000c6  7022              STRB     r2,[r4,#0]            ;286
0000c8  78c2              LDRB     r2,[r0,#3]            ;287  ; responce
0000ca  702a              STRB     r2,[r5,#0]            ;287
0000cc  7982              LDRB     r2,[r0,#6]            ;288  ; responce
0000ce  7032              STRB     r2,[r6,#0]            ;288
0000d0  7942              LDRB     r2,[r0,#5]            ;289  ; responce
0000d2  e00e              B        |L7.242|
                  |L7.212|
0000d4  7a02              LDRB     r2,[r0,#8]            ;293  ; responce
0000d6  7022              STRB     r2,[r4,#0]            ;293
0000d8  79c2              LDRB     r2,[r0,#7]            ;294  ; responce
0000da  702a              STRB     r2,[r5,#0]            ;294
0000dc  7a82              LDRB     r2,[r0,#0xa]          ;295  ; responce
0000de  7032              STRB     r2,[r6,#0]            ;295
0000e0  7a42              LDRB     r2,[r0,#9]            ;296  ; responce
0000e2  e006              B        |L7.242|
                  |L7.228|
;;;299    								{
;;;300    									outp8(P1,responce[FIFTH_REG_L]);
0000e4  7b02              LDRB     r2,[r0,#0xc]  ; responce
0000e6  7022              STRB     r2,[r4,#0]
;;;301    									outp8(P2,responce[FIFTH_REG_H]);
0000e8  7ac2              LDRB     r2,[r0,#0xb]  ; responce
0000ea  702a              STRB     r2,[r5,#0]
;;;302    									outp8(P3,responce[SIXTH_REG_L]);
0000ec  7b82              LDRB     r2,[r0,#0xe]  ; responce
0000ee  7032              STRB     r2,[r6,#0]
;;;303    									outp8(P4,responce[SIXTH_REG_H]);
0000f0  7b42              LDRB     r2,[r0,#0xd]  ; responce
                  |L7.242|
0000f2  703a              STRB     r2,[r7,#0]
                  |L7.244|
;;;304    								}
;;;305    							dataReceived = 0;
0000f4  2200              MOVS     r2,#0
0000f6  618a              STR      r2,[r1,#0x18]  ; dataReceived
0000f8  e7d7              B        |L7.170|
;;;306    						}
;;;307    				}
;;;308    	}
;;;309    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L7.252|
                          DCD      0x50000100
                  |L7.256|
                          DCD      0x40010000
                  |L7.260|
                          DCD      0xe000e100
                  |L7.264|
                          DCD      0x50004000
                  |L7.268|
                          DCD      0x50004100
                  |L7.272|
                          DCD      0x40050000
                  |L7.276|
                          DCD      ||.bss||+0x400
                  |L7.280|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_u8RecData
                          %        1024
                  responce
                          %        15

                          AREA ||.data||, DATA, ALIGN=2

                  boardID
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  g_u32comRbytes
                          DCD      0x00000000
                  g_u32comRhead
                          DCD      0x00000000
                  g_u32comRtail
                          DCD      0x00000000
                  arrayIndex
                          DCD      0x00000000
                  dataReceiving
                          DCD      0x00000000
                  dataReceived
                          DCD      0x00000000
                  seconds
                          DCD      0x00000000
                  i
                          DCD      0x00000000
                  masterCommand
000024  01030000          DCB      0x01,0x03,0x00,0x00
000028  0006c5c8          DCB      0x00,0x06,0xc5,0xc8

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_a80fc96b____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_a80fc96b____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_a80fc96b____REVSH|
#line 132
|__asm___6_main_c_a80fc96b____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
