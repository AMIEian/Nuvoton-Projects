; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\NUC029xAN\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=535 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;85     
;;;86     void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;87     {
;;;88         /*---------------------------------------------------------------------------------------------------------*/
;;;89         /* Init System Clock                                                                                       */
;;;90         /*---------------------------------------------------------------------------------------------------------*/
;;;91         /* Enable IRC22M clock */
;;;92         CLK->PWRCON |= CLK_PWRCON_IRC22M_EN_Msk;
000002  4c17              LDR      r4,|L1.96|
000004  6820              LDR      r0,[r4,#0]
000006  2104              MOVS     r1,#4
000008  4308              ORRS     r0,r0,r1
00000a  6020              STR      r0,[r4,#0]
;;;93     
;;;94         /* Waiting for IRC22M clock ready */
;;;95         CLK_WaitClockReady(CLK_CLKSTATUS_IRC22M_STB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;96     
;;;97         /* Switch HCLK clock source to HIRC */
;;;98         CLK->CLKSEL0 = CLK_CLKSEL0_HCLK_S_HIRC;
000012  2007              MOVS     r0,#7
000014  6120              STR      r0,[r4,#0x10]
;;;99     
;;;100        /* Set PLL to Power-down mode and PLL_STB bit in CLKSTATUS register will be cleared by hardware.*/
;;;101        CLK->PLLCON |= CLK_PLLCON_PD_Msk;
000016  6a20              LDR      r0,[r4,#0x20]
000018  01e1              LSLS     r1,r4,#7
00001a  4308              ORRS     r0,r0,r1
00001c  6220              STR      r0,[r4,#0x20]
;;;102    
;;;103        /* Enable PLL and Set PLL frequency */
;;;104        CLK->PLLCON = PLLCON_SETTING;
00001e  4811              LDR      r0,|L1.100|
000020  6220              STR      r0,[r4,#0x20]
;;;105    
;;;106        /* Waiting for clock ready */
;;;107        CLK_WaitClockReady(CLK_CLKSTATUS_PLL_STB_Msk | CLK_CLKSTATUS_XTL12M_STB_Msk | CLK_CLKSTATUS_IRC10K_STB_Msk);
000022  200d              MOVS     r0,#0xd
000024  f7fffffe          BL       CLK_WaitClockReady
;;;108    
;;;109        /* Switch HCLK clock source to PLL, STCLK to HCLK/2 */
;;;110        CLK->CLKSEL0 = CLK_CLKSEL0_STCLK_S_HCLK_DIV2 | CLK_CLKSEL0_HCLK_S_PLL;
000028  201a              MOVS     r0,#0x1a
00002a  6120              STR      r0,[r4,#0x10]
;;;111    
;;;112        /* Enable peripheral clock */
;;;113        CLK->APBCLK = CLK_APBCLK_UART0_EN_Msk | CLK_APBCLK_TMR0_EN_Msk | CLK_APBCLK_UART1_EN_Msk;
00002c  480e              LDR      r0,|L1.104|
00002e  60a0              STR      r0,[r4,#8]
;;;114    
;;;115        /* Peripheral clock source */
;;;116        CLK->CLKSEL1 = CLK_CLKSEL1_UART_S_PLL | CLK_CLKSEL1_TMR0_S_HIRC;
000030  480e              LDR      r0,|L1.108|
000032  6160              STR      r0,[r4,#0x14]
;;;117    
;;;118        /* Update System Core Clock */
;;;119        /* User can use SystemCoreClockUpdate() to calculate PllClock, SystemCoreClock and CycylesPerUs automatically. */
;;;120        SystemCoreClockUpdate();
000034  f7fffffe          BL       SystemCoreClockUpdate
;;;121    
;;;122        /*---------------------------------------------------------------------------------------------------------*/
;;;123        /* Init I/O Multi-function                                                                                 */
;;;124        /*---------------------------------------------------------------------------------------------------------*/
;;;125        /* Set P3 multi-function pins for UART0 RXD, TXD */
;;;126        SYS->P3_MFP &= ~(SYS_MFP_P30_Msk | SYS_MFP_P31_Msk);
000038  2005              MOVS     r0,#5
00003a  0700              LSLS     r0,r0,#28
00003c  6bc1              LDR      r1,[r0,#0x3c]
00003e  4a0c              LDR      r2,|L1.112|
000040  4011              ANDS     r1,r1,r2
000042  63c1              STR      r1,[r0,#0x3c]
;;;127        SYS->P3_MFP |= (SYS_MFP_P30_RXD0 | SYS_MFP_P31_TXD0);
000044  6bc1              LDR      r1,[r0,#0x3c]
000046  2203              MOVS     r2,#3
000048  4311              ORRS     r1,r1,r2
00004a  63c1              STR      r1,[r0,#0x3c]
;;;128    		
;;;129    		/*---------------------------------------------------------------------------------------------------------*/
;;;130        /* Init I/O Multi-function                                                                                 */
;;;131        /*---------------------------------------------------------------------------------------------------------*/
;;;132        /* Set P1 multi-function pins for UART1 RXD1, TXD1 */
;;;133    		SYS->P1_MFP &= ~(SYS_MFP_P12_Msk | SYS_MFP_P13_Msk);
00004c  6b41              LDR      r1,[r0,#0x34]
00004e  4a09              LDR      r2,|L1.116|
000050  4011              ANDS     r1,r1,r2
000052  6341              STR      r1,[r0,#0x34]
;;;134        SYS->P1_MFP |= (SYS_MFP_P12_RXD1 | SYS_MFP_P13_TXD1);
000054  6b41              LDR      r1,[r0,#0x34]
000056  2203              MOVS     r2,#3
000058  0292              LSLS     r2,r2,#10
00005a  4311              ORRS     r1,r1,r2
00005c  6341              STR      r1,[r0,#0x34]
;;;135    }
00005e  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  |L1.96|
                          DCD      0x50000200
                  |L1.100|
                          DCD      0x00085639
                  |L1.104|
                          DCD      0x00030004
                  |L1.108|
                          DCD      0x01000700
                  |L1.112|
                          DCD      0xfffffcfc
                  |L1.116|
                          DCD      0xfffff3f3

                          AREA ||i.TMR0_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  TMR0_IRQHandler PROC
;;;62      */
;;;63     void TMR0_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4812              LDR      r0,|L2.76|
000004  6881              LDR      r1,[r0,#8]
000006  07c9              LSLS     r1,r1,#31
000008  0fc9              LSRS     r1,r1,#31
;;;64     	{
00000a  d00e              BEQ      |L2.42|
00000c  2101              MOVS     r1,#1
00000e  6081              STR      r1,[r0,#8]
;;;65     			if(TIMER_GetIntFlag(TIMER0) == 1)
;;;66     				{
;;;67     						/* Clear Timer0 time-out interrupt flag */
;;;68     						TIMER_ClearIntFlag(TIMER0);					
;;;69     						if(dataReceiving == 0)
000010  4c0f              LDR      r4,|L2.80|
000012  6921              LDR      r1,[r4,#0x10]  ; dataReceiving
000014  2000              MOVS     r0,#0
000016  2900              CMP      r1,#0
000018  d008              BEQ      |L2.44|
;;;70     							{
;;;71     								for(i = 0; i < 8; i++)
;;;72     									printf("%c", masterCommand[i]);
;;;73     							}	
;;;74     						else
;;;75     							{
;;;76     								seconds = seconds + 1;
00001a  69a1              LDR      r1,[r4,#0x18]  ; seconds
00001c  1c49              ADDS     r1,r1,#1
00001e  61a1              STR      r1,[r4,#0x18]  ; seconds
;;;77     								if(seconds >= 5)
000020  69a1              LDR      r1,[r4,#0x18]  ; seconds
000022  2905              CMP      r1,#5
000024  d301              BCC      |L2.42|
;;;78     									{
;;;79     										seconds = 0;
000026  61a0              STR      r0,[r4,#0x18]  ; seconds
;;;80     										dataReceiving = 0;
000028  6120              STR      r0,[r4,#0x10]  ; dataReceiving
                  |L2.42|
;;;81     									}
;;;82     							}					
;;;83     				}
;;;84     	}
00002a  bd70              POP      {r4-r6,pc}
                  |L2.44|
00002c  61e0              STR      r0,[r4,#0x1c]         ;71  ; i
00002e  4d08              LDR      r5,|L2.80|
000030  3520              ADDS     r5,r5,#0x20           ;72
000032  e007              B        |L2.68|
                  |L2.52|
000034  69e0              LDR      r0,[r4,#0x1c]         ;72  ; i
000036  5c29              LDRB     r1,[r5,r0]            ;72
000038  a006              ADR      r0,|L2.84|
00003a  f7fffffe          BL       __2printf
00003e  69e0              LDR      r0,[r4,#0x1c]         ;71  ; i
000040  1c40              ADDS     r0,r0,#1              ;71
000042  61e0              STR      r0,[r4,#0x1c]         ;71  ; i
                  |L2.68|
000044  69e0              LDR      r0,[r4,#0x1c]         ;71  ; i
000046  2808              CMP      r0,#8                 ;71
000048  d3f4              BCC      |L2.52|
00004a  bd70              POP      {r4-r6,pc}
;;;85     
                          ENDP

                  |L2.76|
                          DCD      0x40010000
                  |L2.80|
                          DCD      ||.data||
                  |L2.84|
000054  256300            DCB      "%c",0
000057  00                DCB      0

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=1

                  UART0_IRQHandler PROC
;;;234    
;;;235    void UART0_IRQHandler(void)
000000  b500              PUSH     {lr}
;;;236    	{
;;;237    			UART_TEST_HANDLE();
000002  f7fffffe          BL       UART_TEST_HANDLE
;;;238    	}
000006  bd00              POP      {pc}
;;;239    
                          ENDP


                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                  UART0_Init PROC
;;;136    
;;;137    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139        /*---------------------------------------------------------------------------------------------------------*/
;;;140        /* Init UART                                                                                               */
;;;141        /*---------------------------------------------------------------------------------------------------------*/
;;;142        /* Reset IP */
;;;143        SYS_ResetModule(UART0_RST);
000002  4804              LDR      r0,|L4.20|
000004  f7fffffe          BL       SYS_ResetModule
;;;144    
;;;145        /* Configure UART0 and set UART0 Baudrate */
;;;146        UART_Open(UART0, 38400);
000008  214b              MOVS     r1,#0x4b
00000a  0249              LSLS     r1,r1,#9
00000c  4802              LDR      r0,|L4.24|
00000e  f7fffffe          BL       UART_Open
;;;147    }
000012  bd10              POP      {r4,pc}
;;;148    
                          ENDP

                  |L4.20|
                          DCD      0x04000010
                  |L4.24|
                          DCD      0x40050000

                          AREA ||i.UART1_Init||, CODE, READONLY, ALIGN=2

                  UART1_Init PROC
;;;148    
;;;149    void UART1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;150    {
;;;151        /*---------------------------------------------------------------------------------------------------------*/
;;;152        /* Init UART                                                                                               */
;;;153        /*---------------------------------------------------------------------------------------------------------*/
;;;154        /* Reset IP */
;;;155        SYS_ResetModule(UART1_RST);
000002  4804              LDR      r0,|L5.20|
000004  f7fffffe          BL       SYS_ResetModule
;;;156    
;;;157        /* Configure UART0 and set UART0 Baudrate */
;;;158        UART_Open(UART1, 9600);
000008  214b              MOVS     r1,#0x4b
00000a  01c9              LSLS     r1,r1,#7
00000c  4802              LDR      r0,|L5.24|
00000e  f7fffffe          BL       UART_Open
;;;159    }
000012  bd10              POP      {r4,pc}
;;;160    
                          ENDP

                  |L5.20|
                          DCD      0x04000011
                  |L5.24|
                          DCD      0x40150000

                          AREA ||i.UART_TEST_HANDLE||, CODE, READONLY, ALIGN=2

                  UART_TEST_HANDLE PROC
;;;163    /*---------------------------------------------------------------------------------------------------------*/
;;;164    void UART_TEST_HANDLE()
000000  b5f0              PUSH     {r4-r7,lr}
;;;165    	{
;;;166    		uint8_t u8InChar = 0xFF;
;;;167    		uint32_t u32IntSts = UART0->ISR;
000002  4834              LDR      r0,|L6.212|
000004  69c5              LDR      r5,[r0,#0x1c]
;;;168    
;;;169    		if(u32IntSts & UART_ISR_RDA_INT_Msk)
000006  2400              MOVS     r4,#0
000008  05e8              LSLS     r0,r5,#23
;;;170    			{
;;;171    				/* Get all the input characters */
;;;172    				while(UART_IS_RX_READY(UART0))
;;;173    					{
;;;174    						/* Get the character from UART Buffer */
;;;175    						u8InChar = UART_READ(UART0);
;;;176    						if(dataReceiving == 1)
;;;177    							{
;;;178    								responce[arrayIndex] = u8InChar;					
00000a  4a33              LDR      r2,|L6.216|
;;;179    								if(arrayIndex == 1)
;;;180    									{
;;;181    										if(responce[arrayIndex] != 0x03)
;;;182    											{
;;;183    												dataReceiving = 0;
;;;184    												arrayIndex = 0;
;;;185    											}
;;;186    									}
;;;187    								if(arrayIndex == 2)
;;;188    									{
;;;189    										if(responce[arrayIndex] != 0x0C)
;;;190    											{
;;;191    												dataReceiving = 0;
;;;192    												arrayIndex = 0;
;;;193    											}
;;;194    									}
;;;195    								arrayIndex = arrayIndex + 1;
;;;196    								if(arrayIndex == 15)
;;;197    									{
;;;198    										dataReceiving = 0;
;;;199    										arrayIndex = 0;
;;;200    										dataReceived = 1;
00000c  2601              MOVS     r6,#1
00000e  4933              LDR      r1,|L6.220|
000010  2800              CMP      r0,#0                 ;169
000012  db41              BLT      |L6.152|
000014  e044              B        |L6.160|
                  |L6.22|
000016  6800              LDR      r0,[r0,#0]            ;175
000018  690b              LDR      r3,[r1,#0x10]         ;176  ; dataReceiving
00001a  b2c0              UXTB     r0,r0                 ;175
00001c  2b01              CMP      r3,#1                 ;176
00001e  d11c              BNE      |L6.90|
000020  68cb              LDR      r3,[r1,#0xc]          ;178  ; arrayIndex
000022  54d0              STRB     r0,[r2,r3]            ;178
000024  68cb              LDR      r3,[r1,#0xc]          ;179  ; arrayIndex
000026  2b01              CMP      r3,#1                 ;179
000028  d105              BNE      |L6.54|
00002a  68cb              LDR      r3,[r1,#0xc]          ;181  ; arrayIndex
00002c  5cd3              LDRB     r3,[r2,r3]            ;181
00002e  2b03              CMP      r3,#3                 ;181
000030  d001              BEQ      |L6.54|
000032  610c              STR      r4,[r1,#0x10]         ;183  ; dataReceiving
000034  60cc              STR      r4,[r1,#0xc]          ;184  ; arrayIndex
                  |L6.54|
000036  68cb              LDR      r3,[r1,#0xc]          ;187  ; arrayIndex
000038  2b02              CMP      r3,#2                 ;187
00003a  d105              BNE      |L6.72|
00003c  68cb              LDR      r3,[r1,#0xc]          ;189  ; arrayIndex
00003e  5cd3              LDRB     r3,[r2,r3]            ;189
000040  2b0c              CMP      r3,#0xc               ;189
000042  d001              BEQ      |L6.72|
000044  610c              STR      r4,[r1,#0x10]         ;191  ; dataReceiving
000046  60cc              STR      r4,[r1,#0xc]          ;192  ; arrayIndex
                  |L6.72|
000048  68cb              LDR      r3,[r1,#0xc]          ;195  ; arrayIndex
00004a  1c5b              ADDS     r3,r3,#1              ;195
00004c  60cb              STR      r3,[r1,#0xc]          ;195  ; arrayIndex
00004e  68cb              LDR      r3,[r1,#0xc]          ;196  ; arrayIndex
000050  2b0f              CMP      r3,#0xf               ;196
000052  d102              BNE      |L6.90|
000054  610c              STR      r4,[r1,#0x10]         ;198  ; dataReceiving
000056  60cc              STR      r4,[r1,#0xc]          ;199  ; arrayIndex
000058  614e              STR      r6,[r1,#0x14]  ; dataReceived
                  |L6.90|
;;;201    									}
;;;202    							}
;;;203    						if(u8InChar == 0x01 && dataReceiving == 0)
00005a  2801              CMP      r0,#1
00005c  d108              BNE      |L6.112|
00005e  690b              LDR      r3,[r1,#0x10]  ; dataReceiving
000060  2b00              CMP      r3,#0
000062  d105              BNE      |L6.112|
;;;204    							{
;;;205    								responce[arrayIndex] = u8InChar;
000064  68cb              LDR      r3,[r1,#0xc]  ; arrayIndex
000066  54d0              STRB     r0,[r2,r3]
;;;206    								dataReceiving = 1;
000068  610e              STR      r6,[r1,#0x10]  ; dataReceiving
;;;207    								arrayIndex = arrayIndex + 1;
00006a  68cb              LDR      r3,[r1,#0xc]  ; arrayIndex
00006c  1c5b              ADDS     r3,r3,#1
00006e  60cb              STR      r3,[r1,#0xc]  ; arrayIndex
                  |L6.112|
;;;208    							}
;;;209    
;;;210    						/* Check if buffer full */
;;;211    						if(g_u32comRbytes < RXBUFSIZE)
000070  680b              LDR      r3,[r1,#0]  ; g_u32comRbytes
000072  2701              MOVS     r7,#1
000074  02bf              LSLS     r7,r7,#10
000076  42bb              CMP      r3,r7
000078  d20e              BCS      |L6.152|
;;;212    							{
;;;213    									/* Enqueue the character */
;;;214    									g_u8RecData[g_u32comRtail] = u8InChar;
00007a  4b19              LDR      r3,|L6.224|
00007c  688f              LDR      r7,[r1,#8]  ; g_u32comRtail
00007e  55d8              STRB     r0,[r3,r7]
;;;215    									g_u32comRtail = (g_u32comRtail == (RXBUFSIZE - 1)) ? 0 : (g_u32comRtail + 1);
000080  688b              LDR      r3,[r1,#8]  ; g_u32comRtail
000082  4818              LDR      r0,|L6.228|
000084  4283              CMP      r3,r0
000086  d101              BNE      |L6.140|
000088  2000              MOVS     r0,#0
00008a  e001              B        |L6.144|
                  |L6.140|
00008c  6888              LDR      r0,[r1,#8]  ; g_u32comRtail
00008e  1c40              ADDS     r0,r0,#1
                  |L6.144|
000090  6088              STR      r0,[r1,#8]  ; g_u32comRtail
;;;216    									g_u32comRbytes++;
000092  6808              LDR      r0,[r1,#0]  ; g_u32comRbytes
000094  1c40              ADDS     r0,r0,#1
000096  6008              STR      r0,[r1,#0]  ; g_u32comRbytes
                  |L6.152|
000098  480e              LDR      r0,|L6.212|
00009a  69c3              LDR      r3,[r0,#0x1c]         ;172
00009c  07db              LSLS     r3,r3,#31             ;172
00009e  d1ba              BNE      |L6.22|
                  |L6.160|
;;;217    							}
;;;218    					}
;;;219    			}
;;;220    
;;;221    		if(u32IntSts & UART_ISR_THRE_INT_Msk)
0000a0  05a8              LSLS     r0,r5,#22
0000a2  d515              BPL      |L6.208|
;;;222    			{
;;;223    				uint16_t tmp;
;;;224    				tmp = g_u32comRtail;
0000a4  6888              LDR      r0,[r1,#8]  ; g_u32comRtail
;;;225    				if(g_u32comRhead != tmp)
0000a6  684a              LDR      r2,[r1,#4]  ; g_u32comRhead
0000a8  b280              UXTH     r0,r0                 ;224
0000aa  4282              CMP      r2,r0
0000ac  d010              BEQ      |L6.208|
;;;226    					{
;;;227    							u8InChar = g_u8RecData[g_u32comRhead];
0000ae  6848              LDR      r0,[r1,#4]  ; g_u32comRhead
0000b0  4808              LDR      r0,|L6.212|
                  |L6.178|
;;;228    							while(UART_IS_TX_FULL(UART0));  /* Wait Tx is not full to transmit data */
0000b2  6982              LDR      r2,[r0,#0x18]
0000b4  0212              LSLS     r2,r2,#8
0000b6  d4fc              BMI      |L6.178|
;;;229    							g_u32comRhead = (g_u32comRhead == (RXBUFSIZE - 1)) ? 0 : (g_u32comRhead + 1);
0000b8  684a              LDR      r2,[r1,#4]  ; g_u32comRhead
0000ba  480a              LDR      r0,|L6.228|
0000bc  4282              CMP      r2,r0
0000be  d101              BNE      |L6.196|
0000c0  2000              MOVS     r0,#0
0000c2  e001              B        |L6.200|
                  |L6.196|
0000c4  6848              LDR      r0,[r1,#4]  ; g_u32comRhead
0000c6  1c40              ADDS     r0,r0,#1
                  |L6.200|
0000c8  6048              STR      r0,[r1,#4]  ; g_u32comRhead
;;;230    							g_u32comRbytes--;
0000ca  6808              LDR      r0,[r1,#0]  ; g_u32comRbytes
0000cc  1e40              SUBS     r0,r0,#1
0000ce  6008              STR      r0,[r1,#0]  ; g_u32comRbytes
                  |L6.208|
;;;231    					}
;;;232    			}
;;;233    	}
0000d0  bdf0              POP      {r4-r7,pc}
;;;234    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L6.212|
                          DCD      0x40050000
                  |L6.216|
                          DCD      ||.bss||+0x400
                  |L6.220|
                          DCD      ||.data||
                  |L6.224|
                          DCD      ||.bss||
                  |L6.228|
                          DCD      0x000003ff

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;242    /*---------------------------------------------------------------------------------------------------------*/
;;;243    int main(void)
000000  2059              MOVS     r0,#0x59
000002  2216              MOVS     r2,#0x16
000004  4c2a              LDR      r4,|L7.176|
000006  2188              MOVS     r1,#0x88
000008  e002              B        |L7.16|
                  |L7.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
                  |L7.16|
000010  6823              LDR      r3,[r4,#0]
000012  2b01              CMP      r3,#1
000014  d1f9              BNE      |L7.10|
;;;244    	{
;;;245    			volatile uint32_t u32InitCount;
;;;246    
;;;247    			/* Unlock protected registers */
;;;248    			SYS_UnlockReg();
;;;249    
;;;250    			/* Init System, peripheral clock and multi-function I/O */
;;;251    			SYS_Init();
000016  f7fffffe          BL       SYS_Init
00001a  2500              MOVS     r5,#0
00001c  6025              STR      r5,[r4,#0]
;;;252    
;;;253    			/* Lock protected registers */
;;;254    			SYS_LockReg();
;;;255    
;;;256    			/* Init UART0 for printf */
;;;257    			UART0_Init();
00001e  f7fffffe          BL       UART0_Init
;;;258    		
;;;259    			/* Init UART1 for printf */
;;;260    			UART1_Init();
000022  f7fffffe          BL       UART1_Init
;;;261    
;;;262    			/* Open Timer0 frequency to 0.5 Hz in periodic mode, and enable interrupt */
;;;263    			TIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1);
000026  4e23              LDR      r6,|L7.180|
000028  2201              MOVS     r2,#1
00002a  06d1              LSLS     r1,r2,#27
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       TIMER_Open
000032  6830              LDR      r0,[r6,#0]
000034  0371              LSLS     r1,r6,#13
000036  4308              ORRS     r0,r0,r1
000038  6030              STR      r0,[r6,#0]
00003a  2401              MOVS     r4,#1
00003c  4f1e              LDR      r7,|L7.184|
00003e  1548              ASRS     r0,r1,#21
000040  6038              STR      r0,[r7,#0]
000042  6830              LDR      r0,[r6,#0]
000044  0049              LSLS     r1,r1,#1
000046  4308              ORRS     r0,r0,r1
000048  6030              STR      r0,[r6,#0]
;;;264    			TIMER_EnableInt(TIMER0);
;;;265    
;;;266    			/* Enable Timer0 ~ Timer3 NVIC */
;;;267    			NVIC_EnableIRQ(TMR0_IRQn);
;;;268    
;;;269    			/* Start Timer0 ~ Timer3 counting */
;;;270    			TIMER_Start(TIMER0);		
;;;271    			
;;;272    			GPIO_SetMode(P4, BIT1, GPIO_PMD_OUTPUT);
00004a  4622              MOV      r2,r4
00004c  2102              MOVS     r1,#2
00004e  481b              LDR      r0,|L7.188|
000050  f7fffffe          BL       GPIO_SetMode
;;;273    			GPIO_SetMode(P0, BIT4, GPIO_PMD_OUTPUT);
000054  2201              MOVS     r2,#1
000056  2110              MOVS     r1,#0x10
000058  4819              LDR      r0,|L7.192|
00005a  f7fffffe          BL       GPIO_SetMode
;;;274    			
;;;275    			/* Enable Interrupt and install the call back function */
;;;276    			UART_ENABLE_INT(UART0, (UART_IER_RDA_IEN_Msk | UART_IER_THRE_IEN_Msk | UART_IER_RTO_IEN_Msk));
00005e  4819              LDR      r0,|L7.196|
000060  6841              LDR      r1,[r0,#4]
000062  2213              MOVS     r2,#0x13
000064  4311              ORRS     r1,r1,r2
000066  6041              STR      r1,[r0,#4]
000068  0320              LSLS     r0,r4,#12
00006a  6038              STR      r0,[r7,#0]
;;;277    			NVIC_EnableIRQ(UART0_IRQn);
;;;278    
;;;279    			while(1)
;;;280    				{
;;;281    					if(dataReceived == 1)
;;;282    						{
;;;283    							if(responce[FIRST_REG_L != 0])
;;;284    								GPIO_TOGGLE(P41);
;;;285    							if(responce[SECOND_REG_L != 0])
;;;286    								GPIO_TOGGLE(P04);	
00006c  4f16              LDR      r7,|L7.200|
00006e  4e16              LDR      r6,|L7.200|
000070  4916              LDR      r1,|L7.204|
;;;287    							for(i = 0; i < 15; i++)
;;;288    								{
;;;289    									UART_WRITE(UART1, responce[i]);
000072  4b17              LDR      r3,|L7.208|
000074  4817              LDR      r0,|L7.212|
000076  3f80              SUBS     r7,r7,#0x80           ;286
                  |L7.120|
000078  6942              LDR      r2,[r0,#0x14]         ;281  ; dataReceived
00007a  2a01              CMP      r2,#1                 ;281
00007c  d1fc              BNE      |L7.120|
00007e  784a              LDRB     r2,[r1,#1]            ;283  ; responce
000080  2a00              CMP      r2,#0                 ;283
000082  d002              BEQ      |L7.138|
000084  6872              LDR      r2,[r6,#4]            ;284
000086  4062              EORS     r2,r2,r4              ;284
000088  6072              STR      r2,[r6,#4]            ;284
                  |L7.138|
00008a  784a              LDRB     r2,[r1,#1]            ;285  ; responce
00008c  2a00              CMP      r2,#0                 ;285
00008e  d002              BEQ      |L7.150|
000090  693a              LDR      r2,[r7,#0x10]         ;286
000092  4062              EORS     r2,r2,r4              ;286
000094  613a              STR      r2,[r7,#0x10]         ;286
                  |L7.150|
000096  61c5              STR      r5,[r0,#0x1c]         ;287  ; i
000098  e005              B        |L7.166|
                  |L7.154|
00009a  69c2              LDR      r2,[r0,#0x1c]  ; i
00009c  5c8a              LDRB     r2,[r1,r2]
00009e  601a              STR      r2,[r3,#0]
0000a0  69c2              LDR      r2,[r0,#0x1c]         ;287  ; i
0000a2  1c52              ADDS     r2,r2,#1              ;287
0000a4  61c2              STR      r2,[r0,#0x1c]         ;287  ; i
                  |L7.166|
0000a6  69c2              LDR      r2,[r0,#0x1c]         ;287  ; i
0000a8  2a0f              CMP      r2,#0xf               ;287
0000aa  d3f6              BCC      |L7.154|
;;;290    								}
;;;291    							dataReceived = 0;
0000ac  6145              STR      r5,[r0,#0x14]  ; dataReceived
0000ae  e7e3              B        |L7.120|
;;;292    						}
;;;293    				}
;;;294    	}
;;;295    
                          ENDP

                  |L7.176|
                          DCD      0x50000100
                  |L7.180|
                          DCD      0x40010000
                  |L7.184|
                          DCD      0xe000e100
                  |L7.188|
                          DCD      0x50004100
                  |L7.192|
                          DCD      0x50004000
                  |L7.196|
                          DCD      0x40050000
                  |L7.200|
                          DCD      0x50004280
                  |L7.204|
                          DCD      ||.bss||+0x400
                  |L7.208|
                          DCD      0x40150000
                  |L7.212|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_u8RecData
                          %        1024
                  responce
                          %        15

                          AREA ||.data||, DATA, ALIGN=2

                  g_u32comRbytes
                          DCD      0x00000000
                  g_u32comRhead
                          DCD      0x00000000
                  g_u32comRtail
                          DCD      0x00000000
                  arrayIndex
                          DCD      0x00000000
                  dataReceiving
                          DCD      0x00000000
                  dataReceived
                          DCD      0x00000000
                  seconds
                          DCD      0x00000000
                  i
                          DCD      0x00000000
                  masterCommand
000020  01030000          DCB      0x01,0x03,0x00,0x00
000024  0006c5c8          DCB      0x00,0x06,0xc5,0xc8

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_a80fc96b____REV16|
#line 118 "..\\..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_a80fc96b____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_a80fc96b____REVSH|
#line 132
|__asm___6_main_c_a80fc96b____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
